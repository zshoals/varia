#include "VGameloop.hpp"

#include "varia/VShared.hpp"
#include "varia/VGameContext.hpp"
#include "varia/VSimulation.hpp"
#include "varia/utility/VMemcpy.hpp"
#include "varia/input/VInput.hpp"
#include "varia/VSystemCallbacks.hpp"

#include "varia/ds/VDS-String.hpp"
#include "varia/ds/VDS-Array.hpp"
#include "varia/ds/VDS-Stringmap.hpp"

#include "kinc/display.h"
#include "kinc/system.h"
#include "kinc/log.h"
#include "kinc/threads/thread.h"



static void v_print_timing_info(Gamestate * gamestate)
{
    // kinc_log(KINC_LOG_LEVEL_INFO, "Player X:    %f", gs->gamedata.player.x);

    kinc_log(KINC_LOG_LEVEL_INFO, 
        ":::::::::::::::::::\n"
        "Cycles:      %d\n"
        "RenderFrms:  %d\n"
        "FixDelta:    %f\n"
        "FixRecip:    %f\n"
        "RenderDelta  %f\n"
        "LastRender:  %f\n"
        "Gametime:    %f\n"
        "VarGametime: %f\n"
        "Update Time: %f\n"
        "Real Time:   %f\n"
        ":::::::::::::::::::\n",
        gamestate->frame_cycles,
        gamestate->rendered_frames,
        gamestate->logic_dt,
        1.0 / gamestate->logic_dt,
        gamestate->render_dt,
        gamestate->previous_rendertime,
        gamestate->logic_cumulative_gameclock,
        gamestate->render_cumulative_gameclock,
        gamestate->total_realtime_fixed_update_time,
        kinc_time()
    );
}

static void v_gameloop_simulate(Gamestate * gs, E_Simulating simulating, E_Simulation_Mode mode)
{
    v_simulation_simulate(gs, simulating, mode);
}

static void v_gameloop_build_graphics_intermediate_representation
(
    Graphics_Intermediate_Representation * ir_out, 
    Gamestate const * visual_world
)
{
    //TODO(<zshoals> 07-27-2023): Build IR before rendering
    //....obviously

    ir_out->renderables[0] = 68306; //Dummy test stuff ignore me remove me asap
}

static void v_gameloop_render(Graphics_Renderer * gfx, Graphics_Intermediate_Representation const * ir)
{
    v_graphics_renderer_render(gfx, ir);
}

void v_gameloop_entrypoint(void * data)
{
    Game_Context * context = static_cast<Game_Context *>(data);
    Gamestate * logic_world = address_of(context->logic_world);
    System_Events * system_events = address_of(context->system_events);

    //Process the Input Event Loop
    //BEGIN:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    {
        //TODO(<zshoals> 07-28-2023): Consider this;
        //  We have two events, one generated by KEY_R and another by SHIFT + KEY_R
        //  how do we handle this? do we resolve collisions with some sort of prioritization or just allow things
        //  through?

        v_input_process_events(address_of(context->input), [&logic_world, &system_events](E_Gameplay_Event e)
        {
            switch (e)
            {
                default:
                {
                    VARIA_UNREACHABLE("Unhandled system event.");
                    break;
                }
                case E_Gameplay_Event::No_Action:
                {
                    break;
                }
                case E_Gameplay_Event::Move_Right_Pressed:
                {
                    Float_64 data = kinc_time();
                    kinc_log(KINC_LOG_LEVEL_INFO, "Right Press detected! %f!", data);
                    break;
                }
                case E_Gameplay_Event::Move_Right_Released:
                {
                    // v_system_events_push(system_events, E_System_Event_Type::System_Window_Attempting_Changes);
                    // v_system_events_push(system_events, E_System_Event_Type::System_Window_Request_Windowed);
                    // v_system_events_push(system_events, E_System_Event_Type::System_Window_Apply_Changes);

                    Float_64 data = kinc_time();
                    kinc_log(KINC_LOG_LEVEL_INFO, "RIGHT RELEASE FUCK YOU detected! %f!", data);
                    break;
                }
                case E_Gameplay_Event::Move_Left_Pressed:
                {
                    Float_64 data = kinc_time();
                    kinc_log(KINC_LOG_LEVEL_INFO, "Left Press detected! %f!", data);
                    break;
                }
                case E_Gameplay_Event::Move_Left_Released:
                {
                    // v_system_events_push(system_events, E_System_Event_Type::System_Window_Attempting_Changes);
                    // v_system_events_push(system_events, E_System_Event_Type::System_Window_Request_Fullscreen);
                    // v_system_events_push(system_events, E_System_Event_Type::System_Window_Apply_Changes);

                    Float_64 data = kinc_time();
                    kinc_log(KINC_LOG_LEVEL_INFO, "LEFT RELEASE FUCK YOU detected! %f!", data);
                    break;
                }
            }
        });
    }
    //END:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



    //Process the System Event Loop
    //BEGIN:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    {
        v_system_events_process(address_of(context->system_events), [&](E_System_Event_Type e)
        {
            switch (e)
            {
                default:
                {
                    VARIA_UNREACHABLE("Unhandled system event.");
                    break;
                }
                //Kinc State Events
                case E_System_Event_Type::System_Window_Vertical_Sync_Enable:
                {
                    logic_world->pending_framebuffer_changes.vertical_sync = true;
                    break;
                }
                case E_System_Event_Type::System_Window_Vertical_Sync_Disable:
                {
                    logic_world->pending_framebuffer_changes.vertical_sync = false;
                    break;
                }
                case E_System_Event_Type::System_Window_Lost_Focus:
                {
                    //NOTE(<zshoals> 07-28-2023): This doesn't completely solve the problem;
                    //  Kinc seems to ignore the next keypress, leading to a double release
                    //  however this at least seems to stop any alt-tab exploit
                    //  Also, keypresses generated here won't be handled until the next frame
                    v_input_trigger_all_keyup_actions(address_of(context->input));
                    logic_world->enable_sleep_in_loop = true;

                    kinc_log(KINC_LOG_LEVEL_INFO, "Lost Focus; all keys released, sleeping loop enabled");

                    break;
                }
                case E_System_Event_Type::System_Window_Gained_Focus:
                {
                    kinc_log(KINC_LOG_LEVEL_INFO, "Gained focus, sleeping loop disabled");
                    logic_world->enable_sleep_in_loop = false;

                    break;
                }
                case E_System_Event_Type::System_Window_Request_Fullscreen:
                {
                    kinc_display_mode_t primary = kinc_display_current_mode(0);
                    logic_world->pending_window_changes.width = primary.width;
                    logic_world->pending_window_changes.height = primary.height;
                    logic_world->pending_window_changes.mode = KINC_WINDOW_MODE_FULLSCREEN;
                    break;
                }
                case E_System_Event_Type::System_Window_Request_Windowed:
                {
                    //TODO(<zshoals> 07-30-2023): We might need to store the old window position
                    //  and size and stuff here too if we change back to windowed mode from fullscreen
                    logic_world->pending_window_changes.mode = KINC_WINDOW_MODE_WINDOW;
                    break;
                }
                case E_System_Event_Type::System_Window_Request_Resize:
                {
                    break;
                }
                case E_System_Event_Type::System_Window_Attempting_Changes:
                {
                    logic_world->pending_window_changes = logic_world->window;
                    logic_world->pending_framebuffer_changes = logic_world->framebuffer;

                    break;
                }
                case E_System_Event_Type::System_Window_Discarding_Changes:
                {
                    logic_world->pending_window_changes = logic_world->window;
                    logic_world->pending_framebuffer_changes = logic_world->framebuffer;

                    break;
                }
                case E_System_Event_Type::System_Window_Apply_Changes:
                {
                    //TODO(<zshoals> 07-27-2023): There might be other useful settings, such as
                    //  changing the window title...but they're kind of optional

                    //TODO(<zshoals> 07-30-2023): Exiting from fullscreen to window mode means the size of the window
                    //  is kind of big...maybe fix and store the previous window size?

                    //NOTE(<zshoals> 07-30-2023): Changing the framebuffer resizes the window, for whatever reason
                    //  so this must be done first if we're doing some exclusive fullscreen stuff
                    kinc_window_change_framebuffer(logic_world->kinc_primary_display_index, address_of(logic_world->pending_framebuffer_changes));
                    kinc_window_change_features(logic_world->kinc_primary_display_index, logic_world->pending_window_changes.window_features);
                    kinc_window_change_mode(logic_world->kinc_primary_display_index, logic_world->pending_window_changes.mode);
                    kinc_window_resize(logic_world->kinc_primary_display_index, logic_world->pending_window_changes.width, logic_world->pending_window_changes.height);

                    logic_world->window = logic_world->pending_window_changes;
                    logic_world->framebuffer = logic_world->pending_framebuffer_changes;

                    break;
                }
            }
        });
    }
    //END:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


    //Process important commands (Kinc state configuration updates, for example)
    //BEGIN:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    {
        //NOTE(<zshoals> 07-28-2023): This might be an expensive operation that isn't needed
        //  a lot of these "system query" type operations are weirdly expensive

        // logic_world->kinc_primary_display_index = kinc_primary_display();
    }
    //END:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


    //Update Current Realtime Parameters
    //BEGIN:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    Float_64 realtime = kinc_time();
    Float_64 realtime_advance = kinc_time() - logic_world->previous_realtime;
    logic_world->previous_realtime = realtime;

    //END:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



    //Logic Step
    //BEGIN:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    {
        logic_world->logic_accumulator += realtime_advance;

        //Max frametime checks / program exit if we get into a nasty death spiral situation
        //BEGIN:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        if 
        (
            logic_world->enable_excessive_frametime_exit &&
            logic_world->recent_frametime_overrun_count >= logic_world->max_frametime_overrun_threshold
        )
        {
            VARIA_UNREACHABLE("Repeatedly exceeding the maximum permissible frametime;"
                "likely in a logic death spiral. Aborting program.");

            kinc_log(KINC_LOG_LEVEL_ERROR, "Repeatedly exceeding the maximum permissible frametime;"
                "likely in a logic death spiral. Aborting program.");
            kinc_stop();
        }
        else if (logic_world->logic_accumulator > logic_world->max_frametime)
        {
            logic_world->recent_frametime_overrun_count += 1;
            logic_world->logic_accumulator = logic_world->max_frametime;
        }
        else
        {
            logic_world->recent_frametime_overrun_count = 0;
        }
        //END:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        


        //Fixed update loop
        //BEGIN:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        logic_world->total_realtime_fixed_update_time = kinc_time();
        while (logic_world->logic_accumulator >= logic_world->fixed_timestep_interval)
        {
            logic_world->logic_adjusted_dt = logic_world->logic_dt * logic_world->logic_timescale;

            logic_world->logic_accumulator -= logic_world->fixed_timestep_interval;

            //TODO(<zshoals> 07-30-2023): Gameclocks should be updated inside simulating because
            //  we might pause the simulation lul
            logic_world->logic_cumulative_gameclock += logic_world->fixed_timestep_interval;

            logic_world->simulation_mode = E_Simulation_Mode::Fixed_Step;
            v_gameloop_simulate(logic_world, logic_world->simulating, logic_world->simulation_mode);

            logic_world->previous_logictime = kinc_time();
        }
        logic_world->total_realtime_fixed_update_time = 
            kinc_time() - logic_world->total_realtime_fixed_update_time;

        //END:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    }
    //END:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::




    //Render Step
    //BEGIN:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    {
        logic_world->render_accumulator += realtime_advance;

        //NOTE(<zshoals> 07-19-2023): Extrapolated time, how far ahead the render time is
        //  from the last recent world step
        logic_world->render_dt = kinc_time() - logic_world->previous_logictime;
        logic_world->render_adjusted_dt = logic_world->render_dt * logic_world->logic_timescale;

        //Frame limiting check
        if //vertical sync off, framelimiter on, haven't reached the accumulator threshold yet
        ( 
            !(logic_world->framebuffer.vertical_sync) &&
            logic_world->enable_framerate_limit &&
            logic_world->render_accumulator <= logic_world->fps_limit
        )
        {
            VARIA_NO_OPERATION();
        }
        else
        {
            Gamestate * visual_world = address_of(context->visual_world);
            //Create an "on demand" gamestate which will not be part of the fixed-step
            //  logic chain, this gamestate is for visual purposes only
            memcpy(visual_world, logic_world, sizeof(*logic_world));

            visual_world->simulation_mode = E_Simulation_Mode::Extrapolate;
            v_gameloop_simulate(visual_world, visual_world->simulating, visual_world->simulation_mode); 
            Graphics_Intermediate_Representation * ir_out = address_of(context->ir_storage);
            v_gameloop_build_graphics_intermediate_representation(ir_out, visual_world);
            v_gameloop_render(address_of(context->gfx), ir_out);

            //TODO(<zshoals> 07-30-2023): Gameclocks should be updated inside simulating because
            //  we might pause the simulation lul
            logic_world->render_cumulative_gameclock += kinc_time() - logic_world->previous_rendertime;
            logic_world->previous_rendertime = kinc_time();

            logic_world->render_accumulator = 0.0;

            logic_world->rendered_frames += 1;
        }
    }
    //END:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    logic_world->frame_cycles += 1;

    if (logic_world->enable_sleep_in_loop)
    {
        kinc_thread_sleep(1);
    }
}



void v_gameloop_initialize(kinc_window_options_t wo, kinc_framebuffer_options_t fbo)
{
	static Game_Context game = ZERO_INIT();
	{
		//[Timing Defaults]
		game.logic_world.fixed_timestep_interval = 1.0 / 480.0;
		game.logic_world.max_frametime = 1.0 / 16.0;
		game.logic_world.max_frametime_overrun_threshold = 10;

		//[Gamestate Defaults]
		game.logic_world.logic_dt = game.logic_world.fixed_timestep_interval;
		game.logic_world.logic_timescale = 1.0;

		//[Gameloop Configuration]
		game.logic_world.enable_excessive_frametime_exit = true;
		game.logic_world.enable_framerate_limit = true;
		game.logic_world.fps_limit = 1.0 / 144.0;

		//[Kinc Settings]
		game.logic_world.window = wo;
		game.logic_world.framebuffer = fbo;
        game.logic_world.pending_window_changes = wo;
        game.logic_world.pending_framebuffer_changes = fbo;
        game.logic_world.kinc_primary_display_index = kinc_primary_display();
	}
	
    kinc_init
    (
        game.logic_world.window.title, 
        game.logic_world.window.width, 
        game.logic_world.window.height,
        address_of(game.logic_world.window),
        address_of(game.logic_world.framebuffer)
    );
    kinc_threads_init();

    //Initialize Input
    //BEGIN:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    {
        Input_Virtual_Action_State * input = address_of(game.input);
        v_input_initialize(input);
        //TODO(<zshoals> 07-27-2023): Mouse stuff?

        v_input_configure_move_right_action(input, KINC_KEY_D, false, false, false);
        v_input_configure_move_left_action(input, KINC_KEY_A, false, false, false);

        //Reset all parameters to their default up state
        v_input_trigger_all_keyup_actions(input);
    }
    //END:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


    //Set Kinc's Environment Callbacks
    //BEGIN:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    {
        System_Events * events = address_of(game.system_events);
        v_system_events_initialize(events);
    }
    //END:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


    v_assets_load_atlas(address_of(game.assets), "output_atlas.k", "atlas_dump.atlas");
    v_assets_load_default_shaders(address_of(game.assets));

	kinc_set_update_callback(&v_gameloop_entrypoint, &game);
	kinc_start();
}